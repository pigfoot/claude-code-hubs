# Claude Development Guidelines (Global Defaults)

## Language Detection
- Auto-detect from substantial messages (ignore "ok"/"go"/"sure")
- Use **most recent** non-English language detected; switch when user changes language
- For ambiguous Chinese text (e.g., "你好"), always prefer Traditional Chinese unless context clearly indicates Simplified
- Code/docs always English

## Context Awareness
**Global settings mode:** These are defaults when projects lack specific guidance.
- Check project-specific CLAUDE.md first
- Adapt to existing patterns over these rules
- Don't force rules on established codebases

## Priority Order (highest first)
1. User's explicit instructions
2. Project's CLAUDE.md
3. Existing code patterns
4. Project docs (CONTRIBUTING.md, DEVELOPMENT.md)
5. These defaults

---

## Universal Rules (NEVER Override)

### Git & Commits
- **NEVER** `--no-verify` or bypass hooks without approval
- **NEVER** commit temp files to root: `test-*.ts`, `debug-*.py`, `temp-*.*`
  - Tests go in `tests/` or `__tests__/`
  - Or add to `.gitignore`
- **ALWAYS** before commit: `git status`, `git diff`, run tests, run linter

### Testing
- **NEVER** disable tests: no `it.skip()`, `@pytest.mark.skip`, commenting
- Fix code to pass OR fix/delete test with documented reason

### Incremental Progress
Every commit must: compile, pass tests, include new tests, follow formatter/linter

### 3-Attempt Rule
After 3 failed attempts on same issue: STOP → document → research → ask user

---

## Project Detection (run before starting)

### 1. Check for project guidance
```bash
view ./CLAUDE.md ./CONTRIBUTING.md ./DEVELOPMENT.md
view ./.specify/memory/constitution.md  # spec-kit projects
```

### 2. Detect project type & tools
```bash
ls package.json pyproject.toml Cargo.toml go.mod pom.xml *.csproj  # Type
find . -name "package.json" -type f  # Monorepo if multiple
view Makefile package.json .github/workflows/*.yml  # Commands
```

### 3. Find similar code (best teacher)
```bash
find . -name "*.{js,ts,py}" -type f | xargs grep -l "pattern"
```
Study: libraries used, structure, testing approach. **Match existing > follow defaults.**

---

## Development Workflow

### Planning Phase (for non-trivial tasks: >3 files, new features, refactors)

**Check for spec-kit first:**
```bash
ls .specify/scripts/  # Has spec-kit?
```

#### If spec-kit present:
1. Use `/speckit.constitution` if not exists
2. Use `/speckit.specify` for requirements
3. Use `/speckit.clarify` to refine specs
4. Use `/speckit.plan` for implementation
5. Use `/speckit.tasks` to generate task list
6. Use `/speckit.implement` to execute

#### If NO spec-kit (fallback):
Use `sequential-thinking` MCP, create `PLAN.md`:
```markdown
# Task: [description]
## Stages
- [ ] Stage 1: [what & why]
- [ ] Stage 2: [what & why]
## Status: Working on Stage 1
```
Update progress, delete when done.

### Implementation Flow (TDD)
1. **Understand**: Study similar code
2. **Test**: Write test first (red)
3. **Implement**: Minimal code (green)
4. **Refactor**: Clean up
5. **Commit**: Use `commit`skill or say "commit changes"
   - Prompt user to do commit automatically or manually
   - Auto-handles: GPG signing, staged files, conventional format with emoji
   - Suggests splits for multi-concern changes
   - If uncertain about emoji/type or need split guidance, commit skill has details

Example commit format:
```
✨ feat: add user authentication

- JWT validation
- Protected routes middleware
- Tests for happy/error paths

Related: Feature 001 - User Auth integration (001-user-auth-spec)
```

### Verification (before next stage)
```bash
[run tests]
[run linter]
git diff       # Self-review
git status     # Check temp files
```

---

## Tooling Defaults

### Detect formatter/linter
```bash
ls .prettierrc* .eslintrc* .pylintrc pyproject.toml .rustfmt.toml
```
If none: JS/TS→Prettier+ESLint, Python→Black+Ruff, Rust→rustfmt+clippy, Go→gofmt+golint
**Ask before adding new tools.**

### Detect test runner
```bash
grep -E '"(jest|vitest|mocha)"' package.json
grep -E '(pytest|unittest)' requirements.txt pyproject.toml
```
Use what's there. Don't add new frameworks without asking.

### Package management
- npm/pnpm/yarn: Check lock files
- pip: Always use `--break-system-packages` (for Claude Code env)
- Virtual envs: Check for `venv/`, `.venv/`, `poetry.lock`

---

## When Stuck: 3-Attempt Rule

After 3 failures: STOP.

### 1. Document (create `BLOCKED.md`)
```markdown
## Issue: [what you're trying to do]
## Attempts
1. Approach: [tried] | Error: [message] | Why failed: [hypothesis]
2. Approach: [tried] | Error: [message] | Why failed: [hypothesis]
3. Approach: [tried] | Error: [message] | Why failed: [hypothesis]
## Analysis: [common pattern]
## Need: [specific question]
```

### 2. Research
```bash
WebSearch "[error] [framework] solution"
WebSearch "[feature] best practices 2025"
context7:resolve-library-id "[library]"
```

### 3. Question fundamentals
- Right abstraction level?
- Split into smaller problems?
- Simpler approach exists?
- Fighting framework?

### 4. Present options
```
Tried 3 approaches (see BLOCKED.md).

Option A: [simpler] - Pros/Cons/Tradeoff
Option B: [different lib] - Pros/Cons/Tradeoff
Option C: [rethink requirement]

Which direction?
```

---

## Quality Patterns

### Simplicity checklist
- Find similar code first
- Simplest thing that works?
- Real or hypothetical problem?

### While writing
- One function = one job: `getUserById(id)` ✓ | `getUserAndUpdateAndEmail(id)` ✗
- Boring > clever: clear loops ✓ | regex golf ✗
- Copy before abstract: 2x note, 3x consider, 4x+ abstract now

### Red flags
- Function >50 lines → split?
- File >500 lines → multiple files?
- Needs paragraph to explain → simpler?
- "Temporary" → will be permanent

### Before commit
```bash
[run tests]           # Works?
git diff              # Clean?
[compare similar]     # Consistent?
[check test coverage] # Tested?
```

Ask: Understand in 6mo? Teammate understand? TODOs left?

---

## Adapt to Context

| Project Type | Approach |
|--------------|----------|
| **Legacy** (old deps, no types) | Match style exactly, no modernizing, fix bugs only |
| **Greenfield** (new, few files) | More freedom, ask about framework/DB/styling, use modern patterns |
| **Monorepo** | Ask which package first, respect boundaries, check shared utils |

---

## MCP Tools Usage

| Tool | When |
|------|------|
| `WebSearch` | Error messages, post-cutoff info, compare approaches |

## Skills Usage
| Skill | When |
|-------|------|
| `commit` | commit changes |
| `context7` | Library best practices, API docs, framework conventions |
| `nano-banana` | Generate images, create AI art, edit images with AI, craft image prompts |
| `superpowers` | Complex problems, multi-stage plans, track reasoning |
| `superpowers` | test-driven-development activates when implementing features |
| `superpowers` | systematic-debugging activates when debugging issues |
| `superpowers` | verification-before-completion activates before claiming work is done |

### Session management (long tasks)
1. Create `PROGRESS.md`: done/next/blockers
2. If context full: save to file, `/clear`, reload, continue

---

## Quick Reference

### Detection commands
```bash
view CLAUDE.md package.json README.md
find . -name "*.ext" | xargs grep "pattern"
ls .specify/  # spec-kit check
```

### Pre-commit
```bash
git status
git diff
[tests]
[linter]
```

### When stuck (3x)
```bash
web_search "error solution"
[create BLOCKED.md]
[ask with options]
```

### Essential mindset
1. Match project > follow rules
2. Simple & boring > clever
3. Test & commit often > big bang
4. Stop at 3 attempts > infinite debug
5. Ask with options > ask open

---

## Additional Resources
Check project's: CLAUDE.md, CONTRIBUTING.md, DEVELOPMENT.md, docs/

When in doubt: 1) Find similar code, 2) Ask user, 3) Choose simpler

---
