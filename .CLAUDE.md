# Claude Development Guidelines (Global Defaults)

## Priority & Context

**Priority Order (highest first):**

1. User's explicit instructions
2. Project's CLAUDE.md
3. Existing code patterns
4. Project docs (CONTRIBUTING.md, DEVELOPMENT.md)
5. These defaults

**Global settings mode:** These are defaults when projects lack specific guidance.

- Check project-specific CLAUDE.md first
- Adapt to existing patterns over these rules
- Don't force rules on established codebases

---

## Core Protocol

### Verify Before Act (No Guessing)

**Never act on "maybe" or "probably" without verification or user confirmation.**

**Standard Verification Workflow:**

1. **Research**: Check external/internal data (Web/Memory)
2. **Inspect**: Check current state (Files/Context)
3. **Test**: Check environment (Exec/Dry-run)
4. **Act**: Only then, proceed

**Rules:**

1. **Verify first** - Read files, check docs, run non-destructive commands
2. **Can't verify → ask user** - Don't guess and proceed
3. **Separate facts from assumptions** - Be explicit about what you know vs. suspect
4. **Check reference implementation** - If project has upstream/reference, check it FIRST

❌ Wrong: "This might not support X, let me try another approach..." (assumes → acts)
✅ Right: "I'm unsure if this supports X. Should I check the docs/source first, or do you know?" (states uncertainty → asks)

### Critical Red Flags & Uncertainty

**STOP immediately if you think:**

- "Let me add a workaround..."
- "I'll fix/convert/transform/adjust this..."
- "This needs a small modification..."
- "Upstream does X but we need Y..."

**When red flag detected:**

1. Read reference/upstream - understand WHY it works
2. Compare with current implementation
3. ASK USER before any deviation

#### CRITICAL: Beware of False Certainty

You are uncertain if ANY of these are true:

- You thought of a solution but didn't see reference do it
- You're about to write code that reference doesn't have
- You think "I know what this needs" but user didn't explicitly say so

**Always Uncertain (MUST ask):**

- Conflicting requirements
- Any deviation from reference (even "obvious" ones)
- Any workaround/fix not in reference
- Any conversion/transformation logic
- Before unexpected or significant changes

**Design Changes Always Require Approval:**

- Changing function signatures or parameters
- Adding conversion/transformation logic
- Modifying how components interact
- Adding code not present in reference

**Example:** Param differs (arm64 vs aarch64)
❌ Add conversion logic immediately
✅ Check upstream → discover it doesn't pass param → ask user

**Anti-pattern:** See problem → assume solution → implement → fails
**Correct:** See problem → check reference → understand why → ask → implement

### Task Completion

"Done" = User's expectation met, not "technically works"

### Reference Implementation First

**If project has upstream/reference code:**

Before implementing ANY feature or fix:

1. Check if reference already handles this
2. Read and understand reference approach
3. Follow reference pattern exactly
4. Only deviate with explicit user approval

**Signs reference exists:**

- Project docs mention "upstream", "based on", "forked from"
- README has "Credits" or "Attribution" section
- Code comments reference another project
- CLAUDE.md mentions reference repository

**When reference differs:**

- ❌ Don't assume reference is wrong
- ❌ Don't add workaround to "fix" it
- ✅ Ask: "Reference does X, we do Y. Should we align?"

### When Implementation Fails

**If project has reference:**

- Failure = you misunderstood reference
- STOP immediately, don't try alternatives
- Re-read reference thoroughly
- ASK: "Reference does X, but I tried Y and failed. What am I missing?"

**If no reference:**

- First failure: STOP and research (WebSearch, docs)
- Still stuck: ASK user with options (see "When Stuck")

**Never "try different approaches" blindly - either follow reference or ask user.**

---

## Before Starting a Task

### 1. Check for handoff and project guidance

**At conversation start, check if `.claude/HANDOFF.md` exists:**
Read it first, resume from there, then delete after task complete.

Read project guidance: `./CLAUDE.md`, `./CONTRIBUTING.md`, `./DEVELOPMENT.md`

### 2. Detect project type & tools

Check for: `package.json`, `pyproject.toml`, `Cargo.toml`, `go.mod`, `pom.xml`, `*.csproj`

- Multiple `package.json` → Monorepo, ask which package first
- Check `Makefile`, `package.json` scripts, `.github/workflows/*.yml` for commands

### 3. Detect tooling

**Formatter/linter:** Check for `.prettierrc*`, `.eslintrc*`, `.pylintrc`, `pyproject.toml`, `.rustfmt.toml`

- If none: JS/TS→Prettier+ESLint, Python→Black+Ruff, Rust→rustfmt+clippy, Go→gofmt+golint
- **Ask before adding new tools**

**Test runner:** Use what's there. Don't add new frameworks without asking.

**Package management:**

- npm/pnpm/yarn: Check lock files
- pip: Always use `--break-system-packages` (for Claude Code env)
- Virtual envs: Check for `venv/`, `.venv/`, `poetry.lock`

### 4. Match project conventions

Before modifying code, learn patterns from existing code:

- Code style, naming, structure
- Commit message format (e.g., if no emoji exists, don't add)
- Testing approach, libraries used

**If your default conflicts with project → ask user first, otherwise follow project.**

---

## Universal Rules (NEVER Override)

### Git & Commits

- **NEVER** `--no-verify` or bypass hooks without approval
- **NEVER** commit temp files to root: `test-*.ts`, `debug-*.py`, `temp-*.*`
  - Tests go in `tests/` or `__tests__/`, or add to `.gitignore`
- **ALWAYS** before commit: `git status`, `git diff`, run tests, run linter

### Testing

- **NEVER** disable tests: no `it.skip()`, `@pytest.mark.skip`, commenting
- Fix code to pass OR fix/delete test with documented reason

### Incremental Progress

Every commit must: compile, pass tests, include new tests, follow formatter/linter

---

## Development Workflow

### Implementation Flow (TDD for code changes)

1. **Understand**: Learn project conventions from existing code
2. **Test**: Write test first (red)
3. **Implement**: Minimal code (green)
4. **Refactor**: Clean up
5. **Commit**: Use `commit` skill or say "commit changes"
   - Follow project's existing commit message format
   - If no convention exists, use conventional commits
   - Suggests splits for multi-concern changes

### Verification (before commit)

- Run tests
- Run linter
- `git diff` - Self-review
- `git status` - Check for temp files

---

## When Stuck

### First: Check if you're following reference correctly

If project has reference and fails:

1. You probably misunderstood reference - re-read it
2. Compare implementation line-by-line with reference
3. Ask: "I followed reference X, but getting error Y. What am I missing?"

**If no reference or greenfield:**

### 1. Research FIRST (before trying alternatives)

- `WebSearch` for error messages or solutions
- `context7` for library docs and best practices
- Read documentation thoroughly

### 2. Question fundamentals

- Right abstraction level?
- Split into smaller problems?
- Simpler approach exists?
- Fighting the framework?

### 3. If still stuck: Ask user with analysis

```
Problem: [clear description]
What I've checked:
- [reference/docs checked]
- [error indicates X]
- [relevant context Y]

My understanding: [what I think is happening]

Should I:
A) [approach based on research] - because [reason]
B) [simpler alternative] - tradeoff: [what we lose]
C) [rethink requirement] - if [condition]

Which direction?
```

**Note:** Present analysis and options, not just "tried many things and failed"

---

## Quality Patterns

### Simplicity checklist

- Match project conventions first
- Simplest thing that works?
- Real or hypothetical problem?

### While writing

- One function = one job: `getUserById(id)` ✓ | `getUserAndUpdateAndEmail(id)` ✗
- Boring > clever: clear loops ✓ | regex golf ✗
- Copy before abstract: 2x note, 3x consider, 4x+ abstract now

### Red flags

- Function >50 lines → split?
- File >500 lines → multiple files?
- Needs paragraph to explain → simpler?
- "Temporary" → will be permanent

---

## Adapt to Context

| Project Type | Approach |
|--------------|----------|
| **Legacy** (old deps, no types) | Match style exactly, no modernizing, fix bugs only |
| **Greenfield** (new, few files) | More freedom, ask about framework/DB/styling, use modern patterns |
| **Monorepo** | Ask which package first, respect boundaries, check shared utils |

---

## Tools & Skills

### MCP Tools

| Tool | When |
|------|------|
| `WebSearch` | Error messages, post-cutoff info, compare approaches |
| `context7` | Library best practices, API docs, framework conventions |

### Skills

| Skill | When |
|-------|------|
| `commit` | Commit changes (follows project conventions) |
| `nano-banana` | Generate images, AI art, image editing |
| `superpowers` | Complex problems, multi-stage plans, track reasoning |

### Context Management

**Create handoff when:**

- Context is filling up
- Completing a feature or milestone
- Switching to different task area
- End of work session

**HANDOFF.md structure:**

- Completed tasks
- Pending items with checkboxes
- Key decisions & context
- Modified files
- Next steps

On resume: read → continue → delete when complete. Suggest `/compact` to continue.

---

## Essential Mindset

1. Match project > follow rules
2. Reference implementation > your assumptions
3. Recognize false certainty > assume you know
4. Simple & boring > clever
5. Understand first > fix immediately
6. Test & commit often > big bang
7. Ask with analysis > try multiple approaches
8. Completion = user's expectation; conflicts → ask first

When in doubt: 1) Check reference, 2) Match project conventions, 3) Ask user, 4) Choose simpler
